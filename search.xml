<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序算法总结]]></title>
    <url>%2F2019%2F04%2F08%2FAlgorithms-Sorting%2F</url>
    <content type="text"><![CDATA[对各种排序算法作一个总结。主要参考《算法导论》第一、二部分，并根据网上的博文作了一些补充。 3种基础的比较排序算法比较排序就是基于比较的排序。最简单的3种比较排序算法的时间复杂度都是\(O(n^2)\)级别的，其中插入排序的时间复杂度与数组初始顺序相关，在接近排好序的的数组中时间复杂度可以接近\(O(n)\)。 选择排序简单选择排序的基本思想是每次从未排序数组中选择最小的元素与首元素交换，直到排完所有元素。 算法分析 时间复杂度：\(O(n^2)\) 空间复杂度：\(O(1)\) 稳定性：稳定 冒泡排序冒泡排序的基本思想是对相邻的元素两两比较，较大的元素向后冒，这样每一趟会将最大的元素“冒泡”到数组顶端，直到处理完所有元素。 算法分析 时间复杂度：\(O(n^2)\) 空间复杂度：\(O(1)\) 稳定性：稳定 插入排序插入排序就像给扑克排序一样，手上是已经排好序的扑克堆，桌上是未排序的扑克堆。从桌上每抽出一张扑克，将其插入到手中合适的位置。 对每个元素的插入操作可以用数组元素交换法，也可以用数组元素移动法。数组元素交换法类似于冒泡排序，将待插入元素不停与前一个元素交换，直到找到合适位置。数组元素移动法省略了多余的交换操作，只需要将前面的元素不断向后移，直到找到合适位置，再将待插入元素插入。 算法分析 时间复杂度：插入排序在最好情况下（数组已经有序），只需要比较n-1次，不需要交换元素，时间复杂度为\(O(n)\)；在最坏情况下（倒序）时间复杂度是\(O(n^2)\)。其平均性能要比选择排序和冒泡排序好得多。 空间复杂度：\(O(1)\) 稳定性：稳定 冲破\(O(n^2)\)的比较排序算法希尔排序希尔排序可以看作是分组的插入排序。希尔排序首先以一个增量gap将数组分为gap个子数组分别执行插入排序，随后逐步缩小增量，继续按分组执行插入排序，直到增量为1，此时整个数组已经基本有序了，再对其执行一次插入排序就能很快得到结果。 希尔排序的一个问题就是增量序列的选择，这是一个数学问题。在此我们选择初始增量为gap=length/2​，并以gap=gap/2​的方式缩小增量。实际上这不是最优的增量序列。对10个元素的数组执行希尔排序示例如下： 算法分析 时间复杂度：希尔排序的时间复杂度与其增量序列的选择有关，是尚未解决的数学难题。其平均时间复杂度要好于\(O(n^2)\)，是第一批冲破\(O(n^2)\)的比较排序算法，比较快的实现能达到\(O(n^{1.3})\)。 空间复杂度：\(O(1)\) 稳定性：不稳定 归并排序运用了分治思想，将数组分为两个子数组分别排序，再将两个子数组合并。 伪代码如下： 算法分析 时间复杂度：\(O(n\log{n})\) 空间复杂度：归并排序不是原址排序。执行归并操作Merge时，需要将原始数组（起码是一半）拷贝出来处理，所以其空间复杂度为\(O(n)\)。 稳定性：稳定 堆排序堆是一颗完全二叉树。堆可以分为最大堆、最小堆。最大堆的每个节点的元素值都大于它的子节点，最小堆反之。对于从小到大排序，我们采用最大堆。 在最大堆中，堆顶元素为最大值。将堆顶元素与堆尾元素交换位置，这样最大值就排在最后了，将该最大值从堆中移除(A.heap-size = A.heap-size - 1)，接着将剩下的元素维护成一个新的最大堆。重复此过程直到堆的大小降到2。 堆排序的伪代码如下： 算法分析 时间复杂度：\(O(n\log{n})\) 空间复杂度：\(O(1)\) 稳定性：不稳定 快速排序和归并排序一样运用了分治思想。通过一个切分元素将数组切分为两个子数组，使左子数组的元素都不大于切分元素，右子数组的元素都大于切分元素。再分别对左右子数组排序，这样整个数组就是有序的了。 快速排序伪代码如下： 快速排序算法的关键在于切分（PARTITION)。《算法导论》中给出的一种切分方法是： 将数组最后一个元素x作为切分元素，将数组剩下的元素分为3个部分：不大于x的、大于x的、待处理的。i指向最后一个不大于x的元素，j指向下一个待处理的元素。 如果A[j]&gt;x，扩充大于x的子数组，继续处理下一个元素(j++)；如果A[j]&lt;=x，扩充不大于x的子数组，这里需要交换A[i+1]和A[j]，并且i和j都要向后移动。 j到达结尾后，只需要将x与第一个大于x的元素（A[i+1]）交换即可完成划分，返回i+1。 图例如下： 算法分析 时间复杂度：\(O(n\log{n})\) 空间复杂度：\(O(1)\) 稳定性：不稳定 线性时间排序最坏情况下，任何比较排序算法的运行时间下界是\(\Omega(nlogn)\)。非比较排序算法可以在线性时间内完成排序，但对输入数据有一定要求。 计数排序前提 n个输入元素中的每一个都是[0, k)之间的整数。 算法描述 计数排序的基本思想很简单，对每一个输入元素x计数，然后计算小于等于x的元素数量。如果有m个数小于等于x，那么x就应该被放在第m个位置。对于有重复元素的输入，需要做一点改动，因为不能把重复元素放在同一个位置上。改动的方案是，从后往前遍历原始数组，将x放在合适位置后，将x的计数值（小于等于x的元素数量）减1，这样下一次碰到x就会将x放在前一个位置，并且保证了稳定性。 计数排序的伪代码如下： 算法分析 时间复杂度：\(O(k+n)\) 空间复杂度：需要辅助数组C用来存储计数值，辅助数组B用来存储排序结果，因此空间复杂度为\(O(k+n)\)。 稳定性：稳定。计数排序的稳定性使其很适合作为基数排序的子过程。 基数排序前提 输入是n个d位的元素，每一位都是[0, k)之间的整数。 算法描述 从低位到高位，分别对输入数组执行稳定排序。基数排序正确性的前提是对每一位排序的子过程必须是稳定的。 基数排序的伪代码如下： 下面是对7个3位的十进制数执行基数排序的过程： 算法分析 时间复杂度：\(O(d(k+n))\) 空间复杂度：\(O(k+n)\) 稳定性：稳定。 桶排序前提 假设输入数组服从均匀分布。简便起见，进一步假设输入数组独立均匀地分布在[0, 1)区间内。 算法思想 将[0, 1)区间划分位n个子区间，称为桶。将n个输入分别放到各个桶中，对每个桶进行排序，然后顺序遍历每个桶，得到排好序的输出结果。 算法分析 时间复杂度：期望运行时间为\(O(n)\) 空间复杂度：\(O(n)\) 稳定性：稳定。 总结比较排序的时空复杂度、稳定性： 排序方法 平均情况 最好情况 最坏情况 空间复杂度 稳定性 选择排序 \(O(n^2)\) \(O(n)\) \(O(n^2)\) \(O(1)\) 稳定 冒泡排序 \(O(n^2)\) \(O(n^2)\) \(O(n^2)\) \(O(1)\) 稳定 插入排序 \(O(n^2)\) \(O(n)\) \(O(n^2)\) \(O(1)\) 稳定 希尔排序 \(O(nlogn)\)~\(O(n^2)\) \(O(n^{1.3})\) \(O(n^2)\) \(O(1)\) 不稳定 归并排序 \(O(nlogn)\) \(O(nlogn)\) \(O(nlogn)\) \(O(n)\) 稳定 堆排序 \(O(nlogn)\) \(O(nlogn)\) \(O(nlogn)\) \(O(1)\) 不稳定 快速排序 \(O(nlogn)\) \(O(nlogn)\) \(O(n^2)\) \(O(1)\) 不稳定 References 图解排序算法（一）、（二） 《算法导论》]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown中插入数学公式]]></title>
    <url>%2F2019%2F04%2F07%2Fmarkdown-with-latex%2F</url>
    <content type="text"><![CDATA[Markdown本身是支持插入LaTex公式的，但hexo不支持LaTex公式的渲染。我们可以调用MathJax引擎来支持LaTex公式的渲染。 Markdown语法Markdown标准语法用$符号表示LaTex公式。 行内公式行内公式以一个$包围：$公式$。 如$E=mc^2$，显示为\(E=mc^2\)。 公式块公式块以$$包围。 如： $$x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;$$ 显示为：$$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$ 调用MathJax引擎以上的Markdown语法在Hexo内无法正确显示，可以调用MathJax引擎辅助渲染。 调用方法很简单，只需要在Markdown文件或模板文件中添加以下js脚本： &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt; 行内公式采用\\(公式\\)格式。例如，输入\\(E=mc^2\\)，显示为\(E=mc^2\)。 公式块依然以$$包围。 LaTex语法参考《一份不太简短的LATEX \(2\varepsilon\)介绍》。 References Markdown中插入数学公式的方法 一份不太简短的LATEX \(2\varepsilon\)介绍]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TCP-IP详解卷1》学习笔记(6)-Ping程序]]></title>
    <url>%2F2019%2F03%2F10%2Ftcp-ip-volumn1-6%2F</url>
    <content type="text"><![CDATA[我们经常用Ping程序来测试两台主机是否通过网络连通。Ping程序实际上是向目的主机发送了一份ICMP回显请求，并等待ICMP回显应答。 我们称发送ICMP回显请求的ping程序为客户，而称被ping的主机为服务器。ping服务器的功能是直接在内核TCP/IP协议栈中实现的。 报文格式ping程序发送的ICMP回显请求和返回的ICMP回显应答报文格式如下。 标识符 Unix系统实现将该字段置为发送进程的ID号。这样即使在同一台主机上同时运行了多个ping程序实例，ping程序也可以识别出返回的信息。 序列号 序列号从0开始，每发送一次新的回显请求就加1。 选项数据 Ping程序输出ping一下学校论坛，输出如下： $ ping www.cc98.orgPING www.cc98.org (10.10.98.98) 56(84) bytes of data.64 bytes from 10.10.98.98 (10.10.98.98): icmp_seq=1 ttl=123 time=0.932 ms64 bytes from 10.10.98.98 (10.10.98.98): icmp_seq=2 ttl=123 time=1.06 ms64 bytes from 10.10.98.98 (10.10.98.98): icmp_seq=3 ttl=123 time=5.71 ms64 bytes from 10.10.98.98 (10.10.98.98): icmp_seq=4 ttl=123 time=1.15 ms64 bytes from 10.10.98.98 (10.10.98.98): icmp_seq=5 ttl=123 time=1.06 ms64 bytes from 10.10.98.98 (10.10.98.98): icmp_seq=6 ttl=123 time=1.24 ms64 bytes from 10.10.98.98 (10.10.98.98): icmp_seq=7 ttl=123 time=1.19 ms64 bytes from 10.10.98.98 (10.10.98.98): icmp_seq=8 ttl=123 time=1.20 ms^C--- www.cc98.org ping statistics ---8 packets transmitted, 8 received, 0% packet loss, time 7006msrtt min/avg/max/mdev = 0.932/1.697/5.715/1.522 ms Ping程序每隔1秒发送一个ICMP回显请求，并在收到应答后计算往返时间（RTT）。 linux系统下Ping程序会不断发送回显请求，直到键入Ctrl-C中断。而Window系统下只会发送4个回显请求，并且在收到上一个应答或超时后才会发送下一个请求。 一般来说第一个RTT会比其他的大。这是因为发送第一个ICMP回显请求之前需要将域名转换为IP地址（域名不在本地缓存中时）、通过ARP获取硬件地址（目的端硬件地址不在ARP高速缓存中时）。 IP记录路由选项Ping程序可以设置IP记录路由（RR）选项，以提供记录路由的功能。linux下是-R选项。 工作流程 ping程序在发送的ICMP回显请求报文中设置IP头部的RR选项 每个处理该报文的路由器都将它的IP地址放入选项字段中 当报文到达目的端时，IP清单地址被复制到ICMP回显应答中 返回途中所经过的路由器IP地址被加入回显报文的IP头部选项字段 ping程序收到回显应答，打印出往返的IP地址清单 缺陷 中间路由器不一定支持RR选项 Ping服务器不一定支持将ICMP回显请求中的RR清单复制到ICMP回显应答中 IP首部最多存放9个IP地址。IP首部长度字段只有4bit，因此整个IP首部最长只有15个32bit字（即60字节），减去IP首部固定长度20字节，RR选项首部3字节，只剩下37字节来存放IP地址清单，最多只能存放9个IP地址。 IP记录路由选项格式IP头部中RR选项的一般格式如下： code 指明IP选项类型。对于RR选项该字段为7。 len 选项总长度，受IP首部长度限制，最大为40。对于RR选项记录最多9个IP地址时，该字段为39。 ptr 指针字段，从1开始计数，指向存放下一个IP地址的位置。初始值为4，每存入1个IP地址，ptr的值加4。ptr=40表示清单已满。 注意，RFC 791指定路由器RR选项中记录的IP地址为出口IP地址。 我在内网测试了一下ping -R选项，发出的ICMP回显请求报文中确实带了RR选项，但返回的ICMP回显应答中没有RR的任何信息。说明目的主机不支持该选项。 IP时间戳选项IP时间戳选项要求路由器将收到数据报的时间戳填入IP头部。这个选项用处不大，但还是抄书列一下。 IP时间戳选项格式如下： code 时间戳选项代码为0x44。 len 选项总长度，一般为36或40。 ptr 与IP记录路由选项的ptr字段相同，指向下一个可用空间在指针。 OF 溢出字段，4bit的值。如果路由器因为没有空间而不能增加时间戳选项，那么它将增加溢出字段。 FL 4bit的值，表示标志字段。含义如下： 时间戳 时间戳的取值与ICMP时间戳请求与应答相同，即UTC时间从午夜开始计算的毫秒数。同样的，打开时间戳高位表示时间戳为非标准值。 References 《TCP/IP详解卷1：协议》]]></content>
      <categories>
        <category>计算机</category>
        <category>《TCP-IP详解卷1》</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TCP-IP详解卷1》学习笔记(5)-ICMP协议]]></title>
    <url>%2F2019%2F03%2F10%2Ftcp-ip-volumn1-5%2F</url>
    <content type="text"><![CDATA[因特网控制报文协议（ICMP，Internet Control Message Protocol）用于传递差错报文等控制信息。 ICMP报文格式ICMP封装在IP数据报内部，报文格式如下： 类型和代码字段：ICMP报文有15种不同类型，同一类型通过代码字段细分。 检验和：该字段是必须的，覆盖整个ICMP报文，算法与IP首部检验和相同。 ICMP类型不同类型的ICMP报文由类型和代码字段唯一标识，如下图： 上图最后两列又把ICMP报文分为查询报文和差错报文，对这两种报文的处理方式不同。 ICMP查询报文地址掩码请求与应答用于查询子网掩码。请求报文一般发往广播地址，而应答则是单播的。 标识符和序列号 由发送端任意设定，应答报文中返回原值。这样发送方就可以把应答与请求进行匹配。 子网掩码 应答报文返回自己的子网掩码。 时间戳请求与应答用于查询另一个系统的当前时间。 发起时间戳 由请求端填写。标准时间戳一般是自午夜起计算的毫秒数，UTC时间。 接收时间戳和传送时间戳 由应答端填写。应答端收到请求报文时填写接收时间戳，发送应答时填写传送时间戳。实际上这两个字段一般设成相同值。 调整时间请求端可根据应答报文调整时间。 计算往返时间（RTT）。RTT=收到应答时的时间-发送请求的时间。 调整本机时间。假设RTT一半用于请求报文的传输，一半用于应答报文的传输，那么 本机时间调整值=接收时间戳-发送时间戳-RTT/2。 另外，当系统返回一个非标准时间戳时（不是自午夜起计算的毫秒数，UTC时间），它将32bit时间戳的高位置1。此时不能计算时间差，因为单位不一致。 其他获取时间日期的方法 daytime服务（RFC 867）。返回自1900年1月1日起计算的秒数，UTC。 网络时间协议（NTP）（RFC 1305）。精确调整一组系统的时钟，误差在毫秒级以内。 分布式时间服务（DTS）。 守护程序timed(8)。同步局域网内系统时钟，不在广域网内工作。 其他查询报文后续章节会介绍其他ICMP查询报文。 ICMP差错报文ICMP差错报文始终包含产生该差错的IP数据报的首部和数据的前8字节，这样接受ICMP差错报文的模块就能把该差错对应到特定协议（IP首部的协议字段）和特定进程（IP数据的前8字节包含TCP/UDP端口号）。 以下情况不会产生ICMP差错报文： ICMP差错报文 目的IP地址是广播地址或多播地址 目的链路层地址是广播地址 不是IP分片的第一片 源地址为零地址、环回地址、广播地址或多播地址（这些地址本就不该作为源地址出现在网络上） ICMP不可达差错ICMP不可达差错报文的一般格式如下： 第2个32bit必须为0。但是当代码字段为4时（“需要分片但设置了不分片比特”），路径MTU发现机制允许路由器把外出接口的MTU填入低16bit。 ICMP规则允许返回多于8个字节的原差错IP数据报中的数据。但是大多数从伯克利派生出的系统只返回8字节。 ICMP报文的处理不同系统对ICMP报文的处理方式不同，下面给出4.4BSD系统对每个可能的ICMP报文的处理方法： References 《TCP/IP详解卷1：协议》]]></content>
      <categories>
        <category>计算机</category>
        <category>《TCP-IP详解卷1》</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TCP-IP详解卷1》学习笔记(4)-ARP和RARP协议]]></title>
    <url>%2F2019%2F03%2F08%2Ftcp-ip-volumn1-4%2F</url>
    <content type="text"><![CDATA[数据链路层有自己的寻址机制，以太网是根据48bit的以太网地址来确定目的接口的，而不关心IP地址。 地址解析协议为IP地址和数据链路层的硬件地址提供映射，ARP将IP地址转为硬件地址，RAPR则将硬件地址转为IP地址。 ARP流程假设链路层是以太网。 发送一个数据包时，IP数据报从IP层传给链路层。 链路层需要填充以太网头部。源地址和协议类型都很容易填入，剩下目的地址，与路由表中的下一站地址相对应。 首先查找本地ARP缓存，看是否有与下一站IP地址对应的硬件地址。若找到，则填入，发送数据报。 若本地ARP缓存中找不到，则广播ARP请求报文，请求拥有该IP地址的主机回应其硬件地址。 收到ARP回应报文，将报文中回应的硬件地址填入以太网头部。 发送IP数据报。 ARP分组格式ARP请求和应答封装在以太网帧中，分组格式如下： 以太网目的地址 一般来说ARP请求是广播的，以太网目的地址全为1；而ARP应答是单播的。 帧类型 0x0806表示ARP。 硬件类型 1表示以太网。 协议类型 0x0800表示IP地址。它的值以太网头部表示IP数据报的类型字段相同，这是有意设计的。 硬件地址长度和协议地址长度 以字节为单位，6和4分别对应以太网硬件地址长度和IP地址长度。 操作类型(op) 1 ARP请求 2 ARP应答 3 RARP请求 4 RARP应答 发送端以太网地址、发送端IP地址、目的以太网地址、目的IP地址 这里有些信息与以太网头部是重复的。 对于一个ARP请求，除目的以太网地址外其他字段都有填充值。 系统收到给自己的ARP请求后，填入自己的硬件地址，然后互换两个目的地址和发送端地址，并把op字段置2发出一个ARP回应。 ARP缓存每台主机上都拥有一个ARP高速缓存，存放最近的IP地址到硬件地址的映射。发送一个IP数据报时，首先在本地ARP缓存中查找目的IP地址对应的硬件地址，不必每次都发送ARP请求报文，从而提高了效率。高速缓存的生存时间一般为20分钟。 我们可以用arp(8)命令查看ARP高速缓存。-e显示所有ARP缓存(linux格式)，-n显示IP地址而不是域名。 $ arp -enAddress HWtype HWaddress Flags Mask Iface192.168.233.1 ether 00:50:56:c0:00:08 C ens33192.168.233.2 ether 00:50:56:ea:30:ed C ens33 ARP缓存更新的情况： 收到ARP请求。ARP请求是广播的，同一网络内任何主机都会收到，从而可根据ARP请求中的发送端IP和MAC地址更新ARP缓存。 收到ARP回应。ARP回应是单播的，只能收到给自己的ARP回应。根据ARP回应中的发送端IP和MAC地址更新ARP缓存。 ARP代理一个网络中的路由器可以代替该网络中的主机发送ARP应答，让外部网络的ARP请求发起者认为路由器就是目的主机，而将分组发送给路由器，再由路由器转发给目的主机。 ARP欺骗也是利用同样的原理，中间主机对所有ARP请求报文进行回复，让所有源主机都将分组发送到中间主机上，以窃取数据。 免费ARP免费ARP指的是系统启动期间，发送ARP查找自己IP地址对应的硬件地址。 作用 确认自己的IP地址是否被占用。如果主机收到了免费ARP请求的回应，说明同一网络上有相同IP地址的其他主机，提醒系统IP配置有误。 更新其他主机的ARP缓存。其他主机收到该免费ARP请求后，可以根据请求中的发送端IP和MAC地址更新ARP缓存。 RARP协议RARP协议概念上比较简单：已知自己的硬件地址，发送RARP请求，从RARP应答中获取对应的IP地址。 RARP协议多用于无盘系统获取IP地址。对于有盘系统，IP地址一般存放在磁盘的配置文件中，但无盘机没有磁盘，只能读取网卡上的硬件地址，然后通过RARP协议从RARP服务器上获得IP地址。 RARP分组格式RARP分组格式与ARP分组格式基本一致。主要区别在于： 以太网帧类型：0x8035 操作类型 3和4分别表示RARP请求和RARP应答。 RARP服务器内核协议栈提供了ARP服务器的实现，因为只需要在收到询问自己IP地址的ARP请求报文时，回答自己的硬件地址就可以了。 然而RARP服务器的实现就比较复杂了，原因在于： RARP服务器是用户进程。内核并不知道网络上所有无盘系统的硬件地址对应的IP地址，这些都需要由服务器的配置文件/etc/ethers指定，由用户进程读取和分析。 RARP服务器需要收发以太网数据帧。在用户进程对以太网帧的收发与系统有关，比如linux上需要指定socket地址族为AF_PACKET。 RARP服务器不能跨网络。RARP请求是在链路层进行广播的，这意味着它们不能经过路由器转发。为了提供备份，在同一网络上往往需要多个RARP服务器，会增加以太网发送冲突的概率。 References 《TCP/IP详解卷1：协议》]]></content>
      <categories>
        <category>计算机</category>
        <category>《TCP-IP详解卷1》</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TCP-IP详解卷1》学习笔记(3)-IP协议]]></title>
    <url>%2F2019%2F03%2F07%2Ftcp-ip-volumn1-3%2F</url>
    <content type="text"><![CDATA[IP协议是TCP/IP协议族的核心协议。 IP提供的是不可靠、无连接的协议。 不可靠（unreliable）的意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区， IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）。 无连接（connectionless）这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明， IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达。 IP首部不含选项的普通IP首部长度固定为20字节，首部格式如下： 网络中传输的字节序为大端，即先传输高字节。比如IP地址为192.168.1.3，先传192，再传168、1、3。然而许多主机都是以小端形式存储数据的，同样的IP地址在主机上从低到高的存储次序为3、1、168、192，所以传输首部之前必须先转换为网络字节序。库函数htons(3)、htonl(3)实现了这个功能。 版本字段 目前的版本号是4，代表IPv4。新一代的IP协议是IPv6。 首部长度 指的是首部占4字节（32bit字）的数目。不含选项的普通IP首部该字段值为5（5个4字节，总共20字节）。 TOS 这8bit中，有4bit的TOS子字段，分别代表最小时延、最大吞吐量、最高可靠性和最小费用。4 bit中只能置其中1 bit。如果所有4 bit均为0，那么就意味着是一般服务。 总长度字段 指的是整个IP数据报的字节数。IP数据报可能会小于以太网的最小数据长度46字节，如果没有总长度字段，IP层就不知道这46字节中哪些是IP数据报，哪些是链路层填充的字节。 标识、标志和片偏移字段 用于IP分片和重组。 TTL 生存时间，每经过一个路由器，该字段值减1。当该字段值为0时，数据报被丢弃，并发送ICMP报文通知源主机。 协议字段 协议字段标识了上层协议是TCP、UDP、ICMP还是IGMP 首部检验和 首部检验和只计算IP首部的检验和，数据部分的校验由上层协议实现。 为了计算一份数据报的IP检验和，首先把检验和字段置为0。然后，对首部中每个16 bit进行二进制反码求和（整个首部看成是由一串16 bit的字组成），结果存在检验和字段中。当收到一份IP数据报后，同样对首部中每个16 bit进行二进制反码的求和。由于接收方在计算过程中包含了发送方存在首部中的检验和，因此，如果首部在传输过程中没有发生任何差错，那么接收方计算的结果应该为全1。如果结果不是全1（即检验和错误），那么IP就丢弃收到的数据报。但是不生成差错报文，由上层去发现丢失的数据报并进行重传。 选项字段 选项字段是可选的，很少被使用。 在有选项字段时，选项字段都是以4字节对齐的，必要时填充0字节，保证IP首部始终是4字节的整数倍，与首部长度字段要求相符。 IP路由选择IP路由选择的概念很简单：根据一个IP数据报的目的IP地址，IP层决定将该报文发给谁。 路由表IP层维护着一张路由表，可以通过route命令查看。 $ route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 192.168.1.1 255.255.255.255 UG 256 0 0 eth0192.168.10.0 192.168.1.1 255.255.255.0 UG 256 0 0 eth0192.168.19.90 192.168.1.1 255.255.255.255 UHG 256 0 0 eth0127.0.0.0 0.0.0.0 255.0.0.0 U 256 0 0 lo127.0.0.1 0.0.0.0 255.255.255.255 U 256 0 0 lo 每条路由表项包含以下条目： 目的IP地址（Destination） 可以是主机地址或网络地址，由标志字段（Flags）指定。 若是主机地址，Genmask为255.255.255.255，Flags包含H，指定一台特定的主机。 若是网络地址，子网范围由Genmask指定， 网关（Gateway） 指定下一站的IP地址。 如果下一站是路由器，即目的地址不在与本主机直接相连的网络上，需要通过路由器转发，则Flags包含G。 标志（Flags） U 路由表项有效。 H 目的地址是主机，而不是一个网络。 G 下一站是路由器，而不是直接相连的接口。 接口（Iface） 为数据报的传输指定一个网络接口。 举个例子，以上路由表输出的第二项： Destination Gateway Genmask Flags Metric Ref Use Iface192.168.10.0 192.168.1.1 255.255.255.0 UG 256 0 0 eth0 表示目的地址为192.168.10网段的报文，从eth0接口发出，下一站路由器是192.168.1.1。 关键点 得到目的IP地址后，IP层搜寻路由表寻找匹配的条目。没有匹配条目则采用默认路由。 目的IP地址始终不变。 目的MAC地址始终为下一站的地址。 子网划分为什么要划分子网？A类和B类地址为主机号分配了24位和16位的空间，实际上在一个网络中不会安排如此多的主机。于是在得到一个特定的网络号后，通常对主机号进一步进行划分，分配一定的比特作为子网号，剩下的才用作主机号。 子网掩码主机知道自己的IP地址，同时还需要知道自己所在的子网。子网掩码确定了一个IP地址中多少比特用于子网号，多少比特用于主机号。 如上图，子网掩码255.255.255.0表示前24位为网络号和子网号，子网掩码255.255.192.0表示前26位为网络号和子网号。假设主机地址是140.252.1.100，则可以表示为140.252.1.100/24和140.252.1.100/26。 References 《TCP/IP详解卷1：协议》]]></content>
      <categories>
        <category>计算机</category>
        <category>《TCP-IP详解卷1》</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TCP-IP详解卷1》学习笔记(2)-链路层]]></title>
    <url>%2F2019%2F03%2F07%2Ftcp-ip-volumn1-2%2F</url>
    <content type="text"><![CDATA[原书中讨论了以太网、SLIP和PPP协议，这里只介绍应用最为广泛的以太网链路层协议。 物理地址IP层有IP地址，类似的，链路层也有自己的地址，称为物理地址（或硬件地址）。以太网物理地址是一个48位的地址，通常用十六进制表示。 在linux下终端输入ifconfig可以看到网络接口对应的物理地址，有类似如下的输出。 ether 40:16:7e:99:a0:56 (Ethernet) 其中40:16:7e:99:a0:56就是网卡的物理地址。 帧格式封装链路层对IP层的数据包封装存在两种帧格式，RFC 894（以太网）和IEEE 802封装。主机必须能发送和接收的是以太网封装格式的分组。 两种封装格式如下图： 以太网封装这是主机必须支持的基本封装格式，也是最常见的封装格式。 首先是6个字节的目的地址和6个字节的源地址。 接着是2字节的类型字段，标识着上层数据报的类型。 0x0800：IP数据报 0x0806：ARP 0x8035：RARP 然后是数据。数据长度限制在46~1500字节之间，对于不足46字节的数据（如ARP和RARP），需要填充至46字节；对于超过1500字节的数据，上层需要对数据报进行分片，也就是IP分片。 最后是4字节的CRC校验码，用来校验数据传输的正确性。关于CRC的具体原理可以参考《A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS》，或者《循环冗余校验（CRC）算法入门引导》。 IEEE 802封装IEEE 802封装格式用长度字段取代了以太网封装中的类型字段，这里的长度指的是后续字段的长度，从LLC头开始到上层数据报结束，但不包括最后的CRC。可以看到长度字段最大为1500（0x05dc），与以太网封装格式中的类型字段不会产生重复，这样主机就可以区分出两种封装格式。 IEEE 802还提供了逻辑链路控制（LLC）等功能，具体字段介绍可参见RFC 1340。 环回接口环回接口允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信。我们平时输入ifconfig命令看到的lo接口就是环回接口。 $ ifconfig...lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 1500 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x0&lt;global&gt; loop (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 可以看到这个接口的IP地址为127.0.0.1，实际上只要是127开头的IP地址都可以，惯例上使用127.0.0.1，并命名为localhost。 下图是环回接口处理IP数据报的过程： 对环回接口的处理是从离开IP层开始的，关键点是： 传给127.0.0.1的数据传给环回接口，不发送到网络上。 传给本机IP地址的数据，传给环回接口，不传给相应的以太网接口也不发送到网络上。 传给广播或多播地址的数据会传给环回接口，同时也会发送到网络上。 MTU如前所述，以太网和IEEE 802.3对数据报的最大长度都有限制，分别是1500字节和1492字节，这称为最大传输单元（MTU）。 如果IP数据报超过了MTU，那么IP层就要对数据报进行分片，使每一片都小于MTU。 路径MTU两台主机之间通过多个网络通信时，各个网络的链路层MTU有可能各不相同。这时起决定性作用的是这条通信链路上最小的MTU，称作路径MTU。 路径MTU取决于选路，从A到B的路由和从B到A的路由有可能不同，因此路径MTU在两个方向上有可能不相等。 RFC 1191描述了路径MTU的发现机制，以后的章节会有介绍。 References 《TCP/IP详解卷1：协议》]]></content>
      <categories>
        <category>计算机</category>
        <category>《TCP-IP详解卷1》</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TCP-IP详解卷1》学习笔记(1)-概述]]></title>
    <url>%2F2019%2F03%2F07%2Ftcp-ip-volumn1-1%2F</url>
    <content type="text"><![CDATA[实验室刚好有这本书，平时没事拿来随手翻一翻，有空的时候再写写读书笔记，希望能坚持吧。 引言为了解决不同主机之间的通信问题，硬件上需要有连接不同计算机的技术，这就是物理层；而软件上需要定义一种通用的协议，其中TCP/IP协议就是应用最广泛的网络协议。 分层OSI有一个七层模型标准，但实际应用最多的是五层协议。 TCP/IP协议从上到下可以分为应用层、运输层、网络层和数据链路层，其实最底层还有物理层，但严格来讲这不属于TCP/IP协议的一部分，TCP/IP协议并不关心物理链路是如何建立的。 IP地址一台计算机的每个网络接口都具有一个IP地址，它是一个32位的二进制数。IP地址分为5类： 通过二进制表示法的前几位可以判断一个IP地址的类别，更简单的方法是通过点分十进制表示法的第一个十进制数： IP地址的分配由互联网络信息中心(InterNIC, Internet Network Information Center)负责，它只分配网络号，主机号由系统管理员负责。现在32位的IP地址已经远远不够用，后面我们会看到对于IP地址耗尽的解决方案。 DNSIP地址很难记，github.com这样的域名就好记多了。然而网络中实际通信用的都是IP地址，那么就需要一个域名到IP地址的转换机制。DNS系统就提供了这样一个机制，它实际上是一个分布式的数据库系统。 端口号网络中的通信实际上不同主机之间的应用程序进行通信，光有IP地址标识一台主机还不够，我们还需要一个16位的端口号来唯一标识主机中的一个应用程序。其中1~1023之间的端口号称为知名端口号，预留给FTP、Telnet等知名服务使用。并且对于相同的服务，TCP/UDP一般使用同一个端口号。在系统文件/etc/services中你可以看到这些服务对应的端口号。 RFCRFC定义了所有关于Internet的标准，其中包括我们将要学习的TCP/IP协议族。 应用编程接口进行网络编程时，内核为应用程序提供了编程接口，应用程序只需要处理通信逻辑，而通信细节（也就是TCP/IP协议的处理）由内核完成。最常用的编程接口是Berkley socket，而SystemV TLI已经被淘汰了。 References 《TCP/IP详解卷1：协议》]]></content>
      <categories>
        <category>计算机</category>
        <category>《TCP-IP详解卷1》</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[启用Hexo的资源文件夹]]></title>
    <url>%2F2019%2F02%2F28%2Fasset-test%2F</url>
    <content type="text"><![CDATA[Hexo上文章的资源文件少的时候，可以全都放在一个目录下，比如source/images/下存放所有文章的图片。但资源文件一旦多起来，这样的管理方式就会显得很乱，这时就要用到Hexo提供的资源文件夹功能，将同一篇文章的资源文件放在同一个文件夹下，便于管理。 启用资源文件夹启用资源文件夹很简单，只需要在站点配置文件_config.yml中将post_asset_folder选项打开。 hexo/_config.ymlpost_asset_folder: true 打开这个功能后，Hexo将会在你每次通过hexo new命令创建新文章时自动创建一个同名文件夹，这篇文章所有的资源都可以放在这个文件夹里，并在你的文章里通过相对路径引用。 通过相对路径引用使用相对路径的常规markdown语法会导致资源文件在首页不能正常显示，正确的引用方式是通过标签插件。 &#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 比如这篇文章开头的图片为wallpaper.jpg，我将它放在同名资源文件夹里，然后在文章开头通过标签插件引用它： &#123;% asset_img wallpaper.jpg &quot;Why So Serious&quot; %&#125; 这样图片就能正确显示了。 这里asset_img的使用格式与img相同，参照Hexo的标签插件。 References 资源文件夹 | Hexo]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试Hexo与Next的标签插件]]></title>
    <url>%2F2019%2F02%2F24%2Ftag-plugins-test%2F</url>
    <content type="text"><![CDATA[Hexo支持标签插件，用来插入一些特殊内容，而Next对其进行了扩展，在这里测试一下效果。 先来看看Hexo原生支持的标签插件。 Block QuoteQuote from a bookDo not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake Quote from an article on the webEvery interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing Code Block_.compactUnderscore.js_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 或者用反引号的方式更简洁 Backtick Code Block效果与Code Block相同，但用的是反引号，与Markdown一致。 hello.cppc++-wiki#include &lt;iostream&gt;int main(void)&#123; std::cout &lt;&lt; "hello!" &lt;&lt; std::endl; return 0;&#125; 其他还有Image用于插入指定大小的图片、YouTube或Vimeo用于插入视频、post_link用于插入指向其他文章的链接等，就不一一列举了。 下面是Next扩展的标签插件。 Centered QuoteRead the fucking source code! Include RawAny raw content may be included with this tag. Full Image没试过，好像意思是可以插入原始大小的图片？ Note Header(without define class style) Default HeaderWelcome to Hexo! Primary HeaderWelcome to Hexo! Info HeaderWelcome to Hexo! Success HeaderWelcome to Hexo! Warning HeaderWelcome to Hexo! Danger HeaderWelcome to Hexo! No icon noteNote without icon: note info no-iconcode block in note tagcode block in note tagcode block in note tag Codeblock in notecode block in note tagcode block in note tagcode block in note tag Lists in noteulululululololololol Table in Note 12345678 ButtonButton with text &amp; iconText & Large Icon Button inside textThis is my home. External URLWelcome to Theme NexT Organization!If you want new feature or want to report a bug, feel free to open an issue.And if you have coding skills, NexT will be glad for your pull request. 看起来似乎和markdown的链接没什么区别？ LabelLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. TabsPermalink for &gt; Tab one.Permalink for &gt; Tab one 1.Permalink for &gt; Tab one 2.Permalink for &gt; Tab one 3. Permalink for &gt; Tab two.Permalink for &gt; Tab two 1.Permalink for &gt; Tab two 2.Permalink for &gt; Tab two 3. Tab one 1Tab one 2Tab one 3This is Tab 1.This is Tab 2.This is Tab 3. Tab two 1Tab two 2Tab two 3This is Tab 1.This is Tab 2.This is Tab 3. References Tag Plugins | Hexo Tag Plugins | NexT]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建git服务器]]></title>
    <url>%2F2019%2F02%2F24%2Fbuild-a-git-server%2F</url>
    <content type="text"><![CDATA[个人项目放在github上可以很好的进行管理，但考虑到网速问题以及有些团队项目不适合放在github上，这时就需要建立一个git服务器进行代码的备份与集中管理。对git用户的管理有两种方式，一种是为每一个成员创建一个账户，另一种是所有用户都通过git账户与服务器交互。 创建git账户​sudo adduser git 禁用shell登录将/etc/passwd文件的git用户那一行最后的/bin/bash改为/usr/bin/git-shell 创建证书登录将需要登录的用户的公钥（即用户的~/.ssh/id_rsa.pub文件）导入到git的/home/git/.ssh/authorized_keys文件里。 也可采用git账户+密码的方式登录，这样需要先设置git账户的密码： sudo passwd git 初始化git仓库选定一个目录为git仓库，如/opt/git sudo mkdir /opt/git 在/opt/git目录下创建一个裸仓库 sudo git init --bare sample.git 记得把owner改为git，否则git用户无法访问 sudo chown -R git:git /opt/git 克隆和推送远程仓库用git clone命令克隆远程仓库： git clone git@server.ip.addr:/opt/git/sample.git 其余的git操作与github无异。 References 搭建Git服务器 - 廖雪峰的官方网站 Git - Getting Git on a Server]]></content>
      <categories>
        <category>计算机</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown效果测试]]></title>
    <url>%2F2019%2F02%2F18%2Fmarkdown-test%2F</url>
    <content type="text"><![CDATA[测试一下Hexo的Markdown支持效果，采用的是马克飞象的示例文档。 欢迎使用马克飞象@(示例笔记本)[马克飞象|帮助|Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#x68;&#117;&#x73;&#x74;&#103;&#x6f;&#99;&#107;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。 References 马克飞象]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客]]></title>
    <url>%2F2019%2F02%2F18%2Fblog-with-hexo%2F</url>
    <content type="text"><![CDATA[为什么要写博客，因为大佬都会写博客。 为了向大佬靠近，一时兴起，想把笔记从印象笔记迁移到博客上，于是有了这篇文章和这个网站。当然，零零碎碎的东西以后还记在印象笔记上，系统性的就决定由这个博客接管了。这里的文章主要放学习笔记，以后也可能会写些其他东西。 下面记录搭建和配置博客的过程吧。 安装过程Hexo和Next的安装过程网上有很多，这里就不赘述了。可以参考【基于Hexo+Coding+Github搭建个人博客的全过程 | 十一種情緒的堆棧】这篇文章。 其实默认的主题Landcsape还挺好看的，所以我选择Next。 Next配置菜单栏配置默认菜单栏只有首页和归档，要为菜单栏添加标签和分类，更改next/_config.yml： menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons / item badges.menu_settings: icons: true badges: true 也就是将menu.tags字段和menu.catecories字段解注释，顺便将menu_settings.badges字段解注释以显示标签、分类和文章的数量。 此时博客菜单栏已经有标签和分类了，但是点进去发现无法进入网页，还需要生成标签和分类的页面。 $ cd your-hexo-site$ hexo new page tags 在source目录下会生成一个tags目录，编辑其中的index.md文件，将type字段改为&quot;tags&quot;： ---title: tagsdate: 2019-01-11 19:51:28type: &quot;tags&quot;--- 这样tags页面就建好了，对于categories页面也这样操作一遍就行了。 侧边栏配置添加社交链接，前面是链接，后面是图标（一直没找到合适的豆瓣图标） social: GitHub: https://github.com/zenlian || github E-Mail: mailto:zeninglian@gmail.com || envelope Steam: https://steamcommunity.com/profiles/76561198316675758 || steam Douban: https://www.douban.com/people/73582537/ || film 添加置顶按钮并显示百分比： sidebar: # Back to top in sidebar. b2t: true # Scroll percent label in b2t button. scrollpercent: true 脚注配置添加建站时间： footer: since: 2019 更改页面脚注为跳动的红心： footer: icon: name: heart animated: true color: "#f00000" footer.icon.name字段表示图标名，可以在Font Awesome网站上找到合适的图标。 实现效果像这样 文章发布配置点开阅读全文从头开始： scroll_to_more: false 保存阅读位置： save_scroll: true 不显示更改时间： post_meta: updated_at: enabled: false 代码块显示复制按钮及已复制信息： codeblock: copy_button: enable: true # Show text copy result show_result: true 更改代码高亮风格： highlight_theme: night 动画效果配置禁用加载动画： motion: enable: false 其他配置指向外部网站的链接后面会显示一个箭头： exturl: true 右上角显示Github角标： github_banner: https://github.com/zenlian || Follow me on GitHub References 文档 | Hexo Getting Started | NexT 基于Hexo+Coding+Github搭建个人博客的全过程 | 十一種情緒的堆棧]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
