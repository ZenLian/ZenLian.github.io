---
title: "linux 内核之伙伴系统"
date: 2020-04-18T22:18:04+08:00
slug: "linux-kernel-buddy"
tags: ["linux内核", "内存管理"]
---

伙伴系统是内核分配页框的算法，用于避免产生过多的外碎片。

伙伴系统要求分配和释放的单位必须为 $2^k$ 个页框，即 1、2、4、8...

$2^k$ 大小的块的第一个页框下标必须是 2 的整数倍。

## 示例

先从一个例子看伙伴系统的工作方式。

假设物理内存为 1MB，1 个页框大小为 64KB：

![linux-kernel-buddy-1.png](/images/linux-kernel-buddy-1.png)

1. 一开始只有 1 块 $2^4$ 个页框大小的空闲内存
2. 分配 $2^0$ 个页框时，不存在 $2^0$ 的空闲页，最接近的是 $2^4$，于是把 $2^4$ 分裂成两个$2^3$，再把 $2^3$ 分裂成两个 $2^2$，一直到分裂出 $2^0$，然后把 $2^0$ 分配出去
3. 分配 $2^1$ 个页框时，因为存在 $2^1$，直接分配
4. 分配 $2^0$，直接分配
5. 分配 $2^1$，不存在，把 $2^2$分裂
6. 释放 B($2^1$)，直接释放
7. 释放 D($2^1$)释放完后与后面的 $2^1$（称为伙伴）合并为 $2^2$
8. 释放 A($2^0$)，直接释放
9. 释放 C($2^0$)，和前面的伙伴合并为 $2^1$，一直迭代合并直到没有伙伴为止。

## 数据结构

```c
struct zone {
    ...
    struct free_area free_area[MAX_ORDER];
    ...
};
struct free_area {
    struct list_head free_list[MIGRATE_TYPES];
    unsigned long nr_free;
};
struct page {
    ...
    struct list_head lru;
    ...
};
```

- 每个区有一个`struct zone`，其中的`free_area`用于描述伙伴系统的空闲内存块。
- `free_area`有`MAX_ORDER`项，第`order`项连接了所有 $2^{order}$ 大小的空闲块。
- $2^{order}$ 个页描述符通过其第一个页描述符的`lru`字段连接到`free_list`空闲链表上。
- `free_list`最早只有一项，后来根据物理页的可移动性分类，进一步减少了内存碎片。

![linux-kernel-buddy-2.png](/images/linux-kernel-buddy-2.png)

## 页分类

内核按照页的可移动性分类，放在不同的空闲链表中。这样可移动的页就可以通过移动位置进一步减少内存碎片。

- 不可移动页(Non-movable pages)：这类页在内存当中有固定的位置，不能移动。内核的核心分配的内存大多属于这种类型
- 可回收页(Reclaimable pages)：这类页不能直接移动，但可以删除，其内容页可以从其他地方重新生成，例如，映射自文件的数据属于这种类型，针对这种页，内核有专门的页面回收处理
- 可移动页:这类页可以随意移动，用户空间应用程序所用到的页属于该类别。它们通过页表来映射，如果他们复制到新的位置，页表项也会相应的更新，应用程序不会注意到任何改变。

如果指定类型的链表中没有空闲块，会按照预定义的顺序到其他迁移类型的链表中寻找。

## Preference

1. [Linux 伙伴系统(一)--伙伴系统的概述](https://blog.csdn.net/vanbreaker/article/details/7605367)
