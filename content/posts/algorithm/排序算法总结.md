---
title: "排序算法总结"
date: 2019-04-08T13:56:00+08:00
slug: "sorting"
tags: ["算法"]
dropCap: true
---

对各种排序算法作一个总结。主要参考《算法导论》第一、二部分，并根据网上的博文作了一些补充。

<!--more-->

## 3种基础的比较排序算法

比较排序就是基于比较的排序。最简单的3种比较排序算法的时间复杂度都是 $O(n^2)$ 级别的，其中插入排序的时间复杂度与数组初始顺序相关，在接近排好序的的数组中时间复杂度可以接近 $O(1)$。

### 选择排序

简单选择排序的基本思想是每次从未排序数组中选择最小的元素与首元素交换，直到排完所有元素。

**算法分析**

- **时间复杂度：** $O(n^2)$
- **空间复杂度：** $O(1)$
- **稳定性：** 稳定

### 冒泡排序

冒泡排序的基本思想是对相邻的元素两两比较，较大的元素向后冒，这样每一趟会将最大的元素“冒泡”到数组顶端，直到处理完所有元素。

![BubbleSort.jpg](BubbleSort.jpg)

**算法分析**

- **时间复杂度：** $O(n^2)$
- **空间复杂度：** $O(1)$
- **稳定性：** 稳定

### 插入排序

插入排序就像给扑克排序一样，手上是已经排好序的扑克堆，桌上是未排序的扑克堆。从桌上每抽出一张扑克，将其插入到手中合适的位置。

![InsertionSort.jpg](InsertionSort.jpg)

对每个元素的插入操作可以用数组元素交换法，也可以用数组元素移动法。数组元素交换法类似于冒泡排序，将待插入元素不停与前一个元素交换，直到找到合适位置。数组元素移动法省略了多余的交换操作，只需要将前面的元素不断向后移，直到找到合适位置，再将待插入元素插入。

**算法分析**

- **时间复杂度：** 插入排序在最好情况下（数组已经有序），只需要比较n-1次，不需要交换元素，时间复杂度为O(n)；在最坏情况下（倒序）时间复杂度是O(n)。其平均性能要比选择排序和冒泡排序好得多。
- **空间复杂度：** $O(1)$
- **稳定性：** 稳定

## 冲破O(n)的比较排序算法

### 希尔排序

希尔排序可以看作是分组的插入排序。希尔排序首先以一个增量gap将数组分为gap个子数组分别执行插入排序，随后逐步缩小增量，继续按分组执行插入排序，直到增量为 1，此时整个数组已经基本有序了，再对其执行一次插入排序就能很快得到结果。
希尔排序的一个问题就是增量序列的选择，这是一个数学问题。在此我们选择初始增量为 gap=length/2，并以 gap=gap/2 的方式缩小增量。实际上这不是最优的增量序列。对10个元素的数组执行希尔排序示例如下：

![ShellSort.jpg](ShellSort.jpg)

**算法分析**

- **时间复杂度：** 希尔排序的时间复杂度与其增量序列的选择有关，是尚未解决的数学难题。其平均时间复杂度要好于 $O(n)$，是第一批冲破 $O(n)$ 的比较排序算法，比较快的实现能达到 $O(n)$。
- **空间复杂度：** $O(1)$
- **稳定性：** 不稳定

### 归并排序

运用了分治思想，将数组分为两个子数组分别排序，再将两个子数组合并。
伪代码如下：

![MergeSortCode.jpg](MergeSortCode.jpg)

**算法分析**

- **时间复杂度：** $O(n\log{n})$
- **空间复杂度：** 归并排序不是原址排序。执行归并操作Merge时，需要将原始数组（起码是一半）拷贝出来处理，所以其空间复杂度为 $O(n)$ 。
- **稳定性：** 稳定

### 堆排序

堆是一颗完全二叉树。堆可以分为最大堆、最小堆。最大堆的每个节点的元素值都大于它的子节点，最小堆反之。对于从小到大排序，我们采用最大堆。
在最大堆中，堆顶元素为最大值。将堆顶元素与堆尾元素交换位置，这样最大值就排在最后了，将该最大值从堆中移除 (A.heapsize = A.heapsize - 1)，接着将剩下的元素维护成一个新的最大堆。重复此过程直到堆的大小降到 2。
堆排序的伪代码如下：

![HeapSortCode.jpg](HeapSortCode.jpg)

![HeapSort.jpg](HeapSort.jpg)

**算法分析**

- **时间复杂度**：$O(n\log{n})$
- **空间复杂度**：$O(1)$
- **稳定性：** 不稳定

### 快速排序

和归并排序一样运用了分治思想。通过一个切分元素将数组切分为两个子数组，使左子数组的元素都不大于切分元素，右子数组的元素都大于切分元素。再分别对左右子数组排序，这样整个数组就是有序的了。
快速排序伪代码如下：

![QuickSortCode.jpg](QuickSortCode.jpg)

快速排序算法的关键在于切分（PARTITION)。《算法导论》中给出的一种切分方法是：
将数组最后一个元素x作为切分元素，将数组剩下的元素分为3个部分：不大于x的、大于x的、待处理的。i指向最后一个不大于x的元素，j指向下一个待处理的元素。

![Partition1.jpg](Partition1.jpg)
如果 A[j]>x，扩充大于x的子数组，继续处理下一个元素(j++)；如果A[j]<=x，扩充不大于x的子数组，这里需要交换A[i+1]和A[j]，并且i和j都要向后移动。

![Partition2.jpg](Partition2.jpg)

j到达结尾后，只需要将x与第一个大于x的元素（A[i+1]）交换即可完成划分，返回i+1。
图例如下：

![Partition.jpg](Partition.jpg)

**算法分析**

- **时间复杂度：** $O(n\log{n})$
- **空间复杂度：** $O(1)$
- **稳定性：** 不稳定

## 线性时间排序

最坏情况下，任何比较排序算法的运行时间下界是 $\Omega(n\log{n})$。非比较排序算法可以在线性时间内完成排序，但对输入数据有一定要求。

### 计数排序

**前提**
n个输入元素中的每一个都是 [0, k) 之间的整数。

**算法描述**
计数排序的基本思想很简单，对每一个输入元素x计数，然后计算小于等于x的元素数量。如果有m个数小于等于x，那么x就应该被放在第m个位置。对于有重复元素的输入，需要做一点改动，因为不能把重复元素放在同一个位置上。改动的方案是，从后往前遍历原始数组，将x放在合适位置后，将x的计数值（小于等于x的元素数量）减1，这样下一次碰到x就会将x放在前一个位置，并且保证了稳定性。

计数排序的伪代码如下：

![CountingSortCode.jpg](CountingSortCode.jpg)

![CountingSort.jpg](CountingSort.jpg)

**算法分析**

- **时间复杂度：** $O(k+n)$
- **空间复杂度：** 需要辅助数组C用来存储计数值，辅助数组B用来存储排序结果，因此空间复杂度为 $O(k+n)$。
- **稳定性：** 稳定。计数排序的稳定性使其很适合作为基数排序的子过程。

### 基数排序

**前提**
输入是n个d位的元素，每一位都是 [0, k) 之间的整数。

**算法描述**
从低位到高位，分别对输入数组执行稳定排序。基数排序正确性的前提是对每一位排序的子过程必须是稳定的。
基数排序的伪代码如下：

![RadixSortCode.jpg](RadixSortCode.jpg)

下面是对7个3位的十进制数执行基数排序的过程：

![RadixSort.jpg](RadixSort.jpg)

- **时间复杂度**： $O(d(k+n))$
- **空间复杂度**： $O(k+n)$
- **稳定性**： 稳定

### 桶排序

**前提**
假设输入数组服从均匀分布。简便起见，进一步假设输入数组独立均匀地分布在[0, 1)区间内。

**算法思想**
将[0, 1)区间划分位n个子区间，称为**桶**。将n个输入分别放到各个桶中，对每个桶进行排序，然后顺序遍历每个桶，得到排好序的输出结果。

![BucketSort.jpg](BucketSort.jpg)

**算法分析**

- **时间复杂度：** 期望运行时间为 $O(n)$
- **空间复杂度：** $O(n)$
- **稳定性：** 稳定

## 总结

![image.png](image.png)

---

## References

1. [图解排序算法（一）](https://www.cnblogs.com/chengxiao/p/6103002.html)、[（二）](https://www.cnblogs.com/chengxiao/p/6104371.html)
2. 《算法导论》
3. [常见排序算法的总结 - 复杂度、实现和稳定性](https://www.jianshu.com/p/916b15eae350)
