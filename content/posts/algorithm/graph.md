---
title: "图算法总结"
date: 2019-05-24T07:42:00+0800
tags: ["算法"]
dropCap: false
---

《算法导论》图算法总结笔记

## 图的表示

图有两种表示方法：邻接链表和邻接矩阵。

对图进行表示有一些约定表述：对于图`G=(V, E)`，`V`表示图的结点集合，`E`表示图的边集合，`|V|`、`|E|`分别表示结点和边的数量。

### 邻接链表

对于图`G=(V, E)`，邻接链表由一个包含`|V|`条链表的数组`Adj`构成。数组的每一项对应一个结点，用链表的方式保存了与该结点邻接的所有的结点。

- **有向图的表示：**结点`u`对应的数组`Adj[u]`只存储`u`指向的结点。因此链表长度由`2|E|`减小为`|E|`。
- **权重图的表示：**权重图是边含有权重值的值，设权重函数`w(u, v)`表示边`(u, v)`的权重，则可将权重值`w`存储在结点`u`的邻接链表的`v`项中。
- **存储空间：**无向图为`|V|+2|E|`，有向图为`|V|+|E|`，因此均为`Θ(V+E)`。
- **邻接链表的缺陷：**无法快速判断`u`、 `v`是否相连，即`(u, v)`是否为图`G`的一条边。只能在邻接链表`Adj[u]`中搜索结点`v`。

### 邻接矩阵

将图G中结点编号为1，2，...，|V|，则图G的邻接矩阵由一个`|V|*|V|`的矩阵`A=a(i,j)`表示。当`(i, j)`为G的一条边时，`a(i, j)=1`，否则`a(i, j)=0`。在无向图中，`a(i, j)=a(j, i)`，因此`A=A^T`，只需要存储矩阵的对角线及以上部分。

- **有向图的表示：**当`(i, j)`为由`i`指向`j`的边时，`a(i, j)`才等于1。
- **权重图的表示：**邻接矩阵表示权重图更简单，只需要将边`(u, v)`的权重`w(u, v)`直接存储在`a(i, j)`中即可。
- **存储空间：**无论有多少条边，都是`Θ(V^2)`。

下图分别为为无向图和有向图的邻接链表表示和邻接矩阵表示。

![undirected-graph.jpg](undirected-graph.jpg)

![directed-graph.jpg](directed-graph.jpg)

## 图的遍历

### BFS

从源结点开始，依次搜索其邻接结点，再搜索下一级邻接结点。
与树的层序遍历思想有些相似。实现的关键是借助一个队列，首先源结点入队。
每弹出队列中一个结点，就将其标为已访问，然后将其**未访问过的**邻接结点入队。重复直到队列为空。

### DFS

类似于树的前序遍历。

实现的关键是**递归调用**。将源节点作为根结点。

首先将根结点标为已访问，然后对根结点的**未访问过的**邻接结点递归调用DFS。

DFS中每个结点有2个访问时间：发现时间（首次访问的时间）和完成时间（其邻接结点都已被发现的时间）。

### 拓扑排序

拓扑排序是针对有向无环图(DAG)的。

- 方法1：根据DFS中每个结点完成时间的逆序排序，即完成了拓扑排序。证明见算法导论。
- 方法2：找到所有入度为0的结点，入队。每弹出队列中1个结点，就在图中删除该节点以及与该结点关联的边，将其入度为0的邻接结点入队。重复直到队列为空。若出队的结点数小于结点总数，说明该图不是有向无环图。

### 强连通分量（TODO）

## 最小生成树

一个连通图有V个结点，一定可以用V-1条边将所有结点连接起来，形成一个生成树。

生成树可以有很多个，其中边的权重之和最小的称为最小生成树。

以下2个最小生成树算法都属于贪心算法。

### Krustal算法

1. 将所有边按权重从小到大排序
1. 按该顺序遍历所有边(u, v)，若u,v不在同一颗树中，将边(u,v)加入

### Prim算法

1. 从任意一个结点出发
1. 选择连接结点的所有边中权重最小的一条加入
1. 将新加入的结点与原集合视为一个整体（可以看作一个结点），重复第2步。

## 最短路径

单源最短路径：从给定源节点 s 到所有节点的最短路径。

最优子结构：最短路径的子路径一定也是最短路径。

### 松弛操作

```
if v.d > u.d + w(u,v)
    v.d = u.d + w(u,v)
    v.pi = u
```

- 其中 u, v 是相邻节点，v.d, u.d 分别表示节点源节点 s 到 v, u 的当前最短路径
- w(u,v) 表示 u, v 之间的权重
- 一次松弛操作简单说就是检查 s 经过 u 再到 v 是否更近

### Bellban-Ford 算法

- 边的权重可以为负值
- 能检测是否存在负权重环路

**算法流程**：

1. 执行 `|V|-1` 次循环（`|V|` 为图的结点数），每次循环对图的每条边进行一次松弛操作。
1. 对每条边 `(u,v)` 进行检查，若 `v.d>u.d+w(u,v)` ，说明存在负权重环路。

### ==TODO==：有向无环图中的单源最短路径

### Dijkstra 算法

- 时间复杂度低于 Bellban-Ford 算法
- 边的权重不能为负值

实现过程类似于 BFS，实现的关键是借助一个节点的最小优先队列。

首先初始化，s.d=0，其余节点.d=无穷大。最小优先队列保存所有节点（关键字为d）。

每次从队列中弹出 d 最小的节点 u ，然后对所有从 u 出发的边进行一次松弛操作。

**相关练习**：

- [Network Delay Time - LeetCode](https://leetcode.com/problems/network-delay-time/)

## ==TODO==：所有节点对的最短路径问题

## ==TODO==：最大流
